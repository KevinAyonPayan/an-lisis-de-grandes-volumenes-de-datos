# -*- coding: utf-8 -*-
"""SisRecom_Parte2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B5bFQOu_rgQEdRItLUqdrLRCX37zdtZN

# Sistema de recomendacion de Item-Item

En la industria hotelera, conocer la experiencia de los clientes es de vital importancia, ya que de esta manera se pueden ofrecer múltiples alternativas que puedan mejorar dicha experiencia y permitan que los usuarios tengan un mejor desarrollo en sus viajes.

Un sistema de recomendación podría mejorar la experiencia de búsqueda en los siguientes viajes guiando al usuario, sugiriendo a manera de "porque te has hospedado en 'x' hotel, tal vez te gustaría estar en 'y' hotel cuando visites 'z' ciudad".

Esto se logra a partir de las visitas anteriores que el usuario valide en la plataforma.

El sistema que estaremos revisando a continuacion opera bajo el mismo principio.

## Dependencias

Pandas para nuestro Data Frame

Matplotlib y seaborn para visualizar los datos.
"""

import numpy as np
import pandas as pd
import sklearn
import matplotlib.pyplot as plt
import seaborn as sns
import scipy

"""## Cargando los datos

Tomados de Kaggle: [515K Hotel Reviews Data in Europe
](https://www.kaggle.com/datasets/jiashenliu/515k-hotel-reviews-data-in-europe).

Esta base de datos tiene toda la información mezclada en un solo archivo, por lo que, además de la limpieza de los datos, tendremos que separarla para una mejor interpretación y análisis

"""

hotels_reviews = pd.read_csv("Hotel_Reviews.csv")
hotels_reviews.head()

"""## Analisis Exploratorio

Se revisan los datos y se separan en dataframes que permitan su procesamiento. revisando cuántos ratings existen, hotels únicos y nacionalidades únicas
"""

n_reviews = len(hotels_reviews)
n_hotels = hotels_reviews['Hotel_Address'].nunique()
n_nationalities = hotels_reviews['Reviewer_Nationality'].nunique()

print(f"Total de Reviews: {n_reviews}")
print(f"Total de Hoteles: {n_hotels}")
print(f"Total de nacionalidades unicos: {n_nationalities}")
print(f"Promedio de ratings por Hotel: {round(n_reviews/n_hotels, 2)}")
print(f"Promedio de ratings por nacionalidad: {round(n_reviews/n_nationalities, 2)}")

hotels_reviews.reset_index()
hotel_info = hotels_reviews[['Hotel_Name', 'Hotel_Address']].drop_duplicates(keep='first', ignore_index=True)
hotel_info.insert(0, 'hotel_id', range(0, len(hotel_info)))
hotel_info.insert(1, 'hotel_country', hotel_info['Hotel_Address'].str.split().str[-1])

hotel_info.loc[hotel_info['hotel_country'] == 'Kingdom', ['hotel_country']] = 'United Kingdom'

#hotel_info['hotel_country'].unique()
print(f"Total de Hoteles: {len(hotel_info)}")
hotel_info.head()

review_info = hotels_reviews[['Hotel_Address', 'Reviewer_Nationality', 'Negative_Review', 'Positive_Review', 'Reviewer_Score', 'Review_Date', 'Total_Number_of_Reviews_Reviewer_Has_Given']]

#review_info.loc[review_info['Hotel_Address'] == hotel_info['Hotel_Address'], 'Hotel_Address']
df = review_info.loc[:5].copy()
df1 = hotel_info.loc[:5].copy()
#df.loc[df.Hotel_Address.isin(df1.Hotel_Address), ['Hotel_Address']] = df1[['hotel_id']].values
#df['Hotel_Address'] = df.apply(lamda row: row['Hotel_Address'] if row)

# dictionary
hotel_dict = {row.Hotel_Address : row.hotel_id for (index, row) in hotel_info.iterrows()}
review_info = review_info.replace({"Hotel_Address":hotel_dict})
#print(hotel_dict)


review_info.columns = review_info.columns.str.replace('Hotel_Address', 'hotel_id')
review_info.head()

"""Total de ratings de los hoteles, utilizando `count()` y `groupby()`. Se agrupan los datos a partir de los ids de hoteles y se contabilizan el numero de ratings."""

user_freq = review_info[['Reviewer_Nationality', 'hotel_id']].groupby('Reviewer_Nationality').count().reset_index()
user_freq.columns = ['Reviewer_Nationality', 'n_ratings']
user_freq.head()

print(f"Numero de reviews por nacionalidad: {user_freq['n_ratings'].mean():.2f}.")

sns.set_style("whitegrid")
plt.figure(figsize=(14,5))
plt.subplot(1,2,1)
ax = sns.countplot(x="Reviewer_Score", data=review_info, palette="rocket")
plt.title("Distribucion de Reviews para Hoteles")

plt.subplot(1,2,2)
ax = sns.kdeplot(user_freq['n_ratings'], fill=True, legend=False)
plt.axvline(user_freq['n_ratings'].mean(), color="k", linestyle="--")
plt.xlabel("# ratings por hotel")
plt.ylabel("densidad")
plt.title("Numero de hoteles rankeadaos por nacionalidad de usuario")
plt.show()

"""### Si deseamos conocer cual es el hotel con el rating promedio mas bajo y cual es la que tiene el ranting mas alto?"""

rating_media = review_info.groupby('hotel_id')[['Reviewer_Score']].mean()
print(f"Hotel con el rating mas bajo")
rating_bajo = rating_media['Reviewer_Score'].idxmin()
hotel_info.loc[hotel_info['hotel_id'] == rating_bajo]

rating_alto = rating_media['Reviewer_Score'].idxmax()
print(f"Hotel con el rating mas alto")
hotel_info.loc[hotel_info['hotel_id'] == rating_alto]

"""Cantidad de ratings que tiene el mejor hotel."""

review_info[review_info['hotel_id']==rating_alto]

"""Revisando los ratings, hay varios hoteles con calificaiones altas
La mejor manera de evaluar la popularidad de un hotel es utilizando Promedios Bayesianos.

## Promedio Bayesiano

Se define de la siguiente manera:

$r_{i} = \frac{C \times m + \Sigma{\text{reviews}}}{C+N}$

Donde $C$ representa la confianza, $m$ representa el promedio aritmetico, y $N$ es el numero total de "reviews" de una pelicula $i$. En este caso, $m$ correspondera al promedio de ratings considerando todas las peliculas. Por definicion, C representa "el tamano tipico del dataset".
"""

hotel_stats = review_info.groupby('hotel_id')[['Reviewer_Score']].agg(['count', 'mean'])
hotel_stats.columns = hotel_stats.columns.droplevel()

C = hotel_stats['count'].mean()
m = hotel_stats['mean'].mean()

def promedio_bayesiano(ratings):
    promedio_bayesiano = (C*m+ratings.sum())/(C+ratings.count())
    return promedio_bayesiano

ratings_promedio_bayesiano = review_info.groupby('hotel_id')['Reviewer_Score'].agg(promedio_bayesiano).reset_index()
ratings_promedio_bayesiano.columns = ['hotel_id', 'promedio_bayesiano']
hotel_stats = hotel_stats.merge(ratings_promedio_bayesiano, on='hotel_id')

hotel_stats = hotel_stats.merge(hotel_info[['hotel_id', 'Hotel_Name', 'hotel_country']])
hotel_stats.sort_values('promedio_bayesiano', ascending=False).head()

"""Con el Promedio Bayesiano se puede notar que el hotel `Intercontinental London The O2`, `Shangri La Hotel at The Shard London`, y `Hotel Esther` son los hoteles con las mejores reseñas.


¿Cuál es ahora e hotel con las peores reseñas según los Promedios Bayesianos?
"""

hotel_stats.sort_values('promedio_bayesiano', ascending=True).head()

"""Con los Promedios Bayesianos, los hoteles ubicados en United Kingdom `Britannia International Hotel Canary`, `Hotel Cavendish`, `Commodore Hotel` son de los que tienen las peores reseñas.

## Transformando los datos

Se utilizara una tecnica denominada [filtrado colaborativo](https://en.wikipedia.org/wiki/Collaborative_filtering) para generar recomendaciones para el usuario. Esta técnica parte de la suposicion de homogeneidad en los datos (usuarios similares les interesan las mismas cosas). El filtrado colaborativo es un tipo de aprendizaje no supervisado que realiza predicciones acerca de los intereses de un usuario al aprender de los intereses de una poblacion de gran tamaño.

El primer paso del filtrado colaborativo consiste en transformar los datos en una `matriz usuario-item (user-item matrix)`. En dicha matriz, las filas representan a los usuarios y las columnas representan a los items. El filtrado colaborativo no requiere de informacion sobre los usuarios o los items para generar las recomendaciones.


<img src="imagenes/user-movie-matrix.png" width="500px" align="left">

La funcion `create_X()` crea una matriz dispersa X a partir de 4 diccionarios de mapeo principales

- **mapeo_usuario:** mapea el ID usuario al indice del usuario
- **mapeo_pelicula:** maps movie id to movie index
- **user_inv_mapper:** maps user index to user id
- **movie_inv_mapper:** maps movie index to movie id

Requerimos de estos diccionarios porque mapean la fila y columna de la matriz de utilidad corresponden que ID de usuario e ID de película, respectivamente.

La matriz **X** (user-item) matrix es una matriz [scipy.sparse.csr_matrix](scipylinkhere) que almacena los datos de manera disperas.
"""

from scipy.sparse import csr_matrix

def create_X(df):
    """
    Genera una matriz dispersa a partir del dataframe de ratings

    Argumentos:
        df: dataframe en pandas

    Regresa:
        X: matriz dispersa
        mapeo_nacionalildad: dict que mapea las nacionalidades de los usuarios con los indices
        mapeo_inverso_nac: dict que mapea los indices con las nacionalidades de los usuarios
        mapeo_hotel: dict que mapea los id's de los hoteles con los indices de los hoteles
        mapeo_inverso_hotel: dict que mapea los indices de los hoteles con los id's de los hoteles
    """
    N = df['Reviewer_Nationality'].nunique()
    M = df['hotel_id'].nunique()

    mapeo_nacionalildad = dict(zip(np.unique(df["Reviewer_Nationality"]), list(range(N))))
    mapeo_hotel = dict(zip(np.unique(df["hotel_id"]), list(range(M))))

    mapeo_inverso_nac = dict(zip(list(range(N)), np.unique(df["Reviewer_Nationality"])))
    mapeo_inverso_hotel = dict(zip(list(range(M)), np.unique(df["hotel_id"])))

    user_index = [mapeo_nacionalildad[i] for i in df['Reviewer_Nationality']]
    movie_index = [mapeo_hotel[i] for i in df['hotel_id']]

    X = csr_matrix((df["Reviewer_Score"], (movie_index, user_index)), shape=(M, N))

    return X, mapeo_nacionalildad, mapeo_hotel, mapeo_inverso_nac, mapeo_inverso_hotel

X, nac_mapper, hotel_mapper, nac_inv_mapper, hotel_inv_mapper = create_X(review_info)

"""Se calcula la dispersion de nuestra matriz X al dividir el total de elementos no ceros por el total de elementos."""

sparsity = X.count_nonzero()/(X.shape[0]*X.shape[1])

print(f"Dispersion de la Matriz: {round(sparsity*100,2)}%")

"""Esto indica que el 19.22% de las celdas de la matriz nacionalidad-item tienen ratings. (Regularmente esto sucede en este tipo de matrices y como regla general la dispersion no debe ser menor a 0.5% para obtener resultados aceptables).

### Guardando la matriz a un archivo

Guardaremos la matriz usuario-item para el siguiente paso. Dado que nuestra matriz esta representada como una matriz dispersa scipy (scipy sparse matrix),utilizaremos el metodo [scipy.sparse.save_npz](https://docs.scipy.org/doc/scipy-1.1.0/reference/generated/scipy.sparse.load_npz.html) para guardar nuestra matriz como archivo.
"""

from scipy.sparse import save_npz

save_npz('datos/matriz_usuario_item.npz', X)

"""

## Hallando Hoteles similares utilizando KNN (k-Nearest Neighbours)

Al utilizar esta estrategia, podemos hallar los $k$ vecinos de un hotel determinado al identificar los $k$ puntos en el dataset que estan mas cercanos al hotel $m$. kNN hace uso de metricas de distancias tales como:

1. Similaridad Coseno (Cosine similarity)
2. Distancia Euclidiana (Euclidean distance)
3. Distancia Manhattan (Manhattan distance)
4. Correlacion de Pearson (Pearson correlation )

Es un tanto cuanto dificil de visualizar, pero estamos trabajando en un espacio multidimensional M (donde M representa el numero de peliculas en nuestra matriz X)
"""

from sklearn.neighbors import NearestNeighbors

def encuentra_hoteles_parecidos(hotel_id, X, k, metric='cosine', show_distance=False):
    """
    Encuentra los k-vecinos para un pelicula dada (a partir de su id)

    Argumentos:
        hotel_id: id de la pelicula en cuestion
        X: matriz de utilidad usuario-item
        k: numero de peliculas similares a encontrar
        metric: metrica a utilizar para los calculos de kNN

    Devuelve:
        lista de k ID's de hotles similares
    """
    neighbour_ids = []

    hotel_ind = hotel_mapper[hotel_id]
    hotel_vec = X[hotel_ind]
    k+=1
    kNN = NearestNeighbors(n_neighbors=k, algorithm="brute", metric=metric)
    kNN.fit(X)
    if isinstance(hotel_vec, (np.ndarray)):
        hotel_vec = hotel_vec.reshape(1,-1)
    neighbour = kNN.kneighbors(hotel_vec, return_distance=show_distance)
    for i in range(0,k):
        n = neighbour.item(i)
        neighbour_ids.append(hotel_inv_mapper[n])
    neighbour_ids.pop(0)
    return neighbour_ids

"""`encuentra_hoteles_parecidas()` toma movie ID y la matriz user-item X, y despliega una lista de $k$ peliculas que son parecidas al hotelId en cuestion.

Crearemos ahora un mapeo de `hotelId` a `hotel` para que los resultados sean faciles de interpretar.
"""

nombre_hoteles = dict(zip(hotel_info['hotel_id'], hotel_info['Hotel_Name']))

hotel_id = 10

ids_parecidos = encuentra_hoteles_parecidos(hotel_id, X, k=5)
nombre_hotel = nombre_hoteles[hotel_id]

print(f"Por que te hospedaste en {nombre_hotel}")
print(f"Te pueden interesar los siguientes hoteles:")
for i in ids_parecidos:
    print(nombre_hoteles[i])

"""Los resultados obtenidos muestran los 5 hoteles mas parecidas al Hotel Trianon Rive Gauche.

Se puede utilizar una metrica de distancia distinta, como euclidiana o manhattan en lugar de coseno.
"""

nombre_hoteles = dict(zip(hotel_info['hotel_id'], hotel_info['Hotel_Name']))

movie_id = 10
ids_parecidos = encuentra_hoteles_parecidos(hotel_id, X, k=5, metric="euclidean")

nombre_hotel = nombre_hoteles[hotel_id]
print(f"Porque fuiste al hotel {nombre_hotel}:")
print(f"Te pueden interesar los siguientes hoteles:")
for i in ids_parecidos:
    print(nombre_hoteles[i])